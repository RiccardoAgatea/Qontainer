\subsection{Altre Classi} % (fold)
\label{sub:altre_classi}
Oltre alla gerarchia radicata in \code{Order} e al template \code{Container}, sono state definite altre classi.
\subsubsection{Template DeepPtr} % (fold)
\label{ssub:template_deepptr}
Il template di classe \code{DeepPtr<T>} è un template per puntatori smart. Gli oggetti delle classi istanziate da questo template utilizzano un campo dati di tipo \code{T *} per la gestione di oggetti anche polimorfi. La gestione profonda della memoria è garantita grazie a costruttore di copia, costruttore di move, operatore di assegnazione di copia, operatore di assegnazione di move, e distruttore. I rimanenti costruttori generano puntatori smart ad una copia dell'oggetto passato come parametro. Sono forniti operatori di dereferenziazione e di dereferenziazione e selezione, ciascuno in due versioni, \code{const} e non-\code{const}, ed operatori di confronto, che eseguono il confronto fra gli oggetti puntati. Sono inoltre forniti i metodi \code{swap()}, per scambiare i contenuti di due puntatori smart, e \code{takeResponsibility()}, per associare il puntatore smart ad un oggetto preesistente, invece di costruirne uno di copia. Per la copia e il confronto vengono utilizzati dei template di funzione contenuti nel namespace \code{UniformInterface}, che nella loro versione di default chiamano un metodo \code{clone()} e l'operatore di uguaglianza, ma che in caso di tipi privi di questi metodi permettono di essere adattati attraverso la specializzazione.
% subsubsection template_deepptr (end)
\subsubsection{Eccezioni} % (fold)
\label{ssub:eccezioni}
Sono state definite le classi \code{EmptyContainer}, \code{InvalidFile}, \code{InvalidIterator}, \code{NullPrtExcept}, e \code{UnavailableFile} per sollevare eccezioni. \code{InvalidFile} e \code{UnavailableFile} derivano da \code{std::invalid_argument}, mentre le restanti derivano da \code{std::logic_error}. Comunque tutte le classi sono parte della gerarchia radicata in \code{std::exception}.
% subsubsection eccezioni (end)
\subsubsection{Finestre di Dialogo} % (fold)
\label{ssub:finestre_di_dialogo}
Le classi \code{AddOrderDialog}, \code{EditOrderDialog}, e \code{SearchDialog} forniscono all'utente della GUI la possibilità di inserire informazioni, nello specifico per inserire nuovi ordini, modificare ordini esistenti, e selezionare ordini che rispettano specifiche caratteristiche. Sono tutte derivate da \code{QDialog}, in modo da rendere modali le finestre associate ai rispettivi oggetti. Tutte sfruttano \code{Order::info()} per rappresentare i dettagli specifici del tipo selezionato nel modo appropriato. In \code{AddOrderDialog} e \code{EditOrderDialog} le informazioni inserite dall'utente sono comunicate all'applicazione attraverso dei metodi essenzialmente analoghi a dei getter, mentre \code{SearchDialog} sfrutta due getter per comunicare se includere gli ordini in attesa e/o quelli completati, ed un metodo che ritorna un oggetto di tipo \code{std::function} che racchiude un predicato ad un parametro di tipo \code{const Order &} e ritorna \code{true} se e solo se il parametro rispetta le condizioni inserite dall'utente.
% subsubsection finestre_di_dialogo (end)
\subsubsection{OrderWidget} % (fold)
\label{ssub:orderwidget}
La classe \code{OrderWidget}, derivata da \code{QFrame}, permette di rappresentare gli ordini nella GUI. Contiene dei pulsanti che permettono all'utente di modificare l'ordine, completarlo o rimuoverlo, e sfrutta dei segnali per comunicare queste informazioni al resto dell'applicazione. Ogni oggetto di tipo \code{OrderWidget} contiene un indice (cioè un campo dati di tipo \code{Model::Index}, descritto in seguito) che punta al corrispettivo ordine. Come le finestre di dialogo, la classe sfrutta \code{Order::info()} per rappresentare i dettagli specifici dell'ordine nel modo appropriato. Ogni \code{OrderWidget} mostra un'icona appropriata al tipo dell'ordine associato, ed in caso di estensione della gerarchia è necessario aggiungere le icone necessarie attraverso il resource system di Qt. In particolare, l'immagine relativa al tipo \code{example} deve essere accessibile attraverso il prefisso \code{/type} e l'alias \code{example}: il path completo, indipendentemente dal nome del file, deve essere \code{:/type/example}.
% subsubsection orderwidget (end)
\subsubsection{Model, View, SearchView} % (fold)
\label{ssub:model_view_searchview}
Le classi \code{Model} e \code{View} costituiscono il fulcro dell'applicazione. \code{Model} racchiude la logica del programma, gestisce i due container di ordini in attesa e completati, permette di aggiungere ordini, rimuoverli, spostarli da un container all'altro, salvare su file e caricare da file, cercare all'interno dei due container ordini che rispettano certe caratteristiche, e ottenere l'elenco degli ordini incompleti. Espone il tipo \code{Model::Index}, che coincide con il tipo iteratore di \code{Container<Order>}, per permettere alla GUI di mantenere un collegamento diretto con gli ordini. \code{View}, classe derivata da \code{QMainWindow}, rappresenta la finestra principale dell'applicazione. È dotata di una toolbar per le operazioni eseguibili, ed utilizza una \code{QScrollArea} per visualizzare l'elenco degli ordini, ciascuno rappresentato da un \code{OrderWidget}. La classe \code{SearchView}, derivata da \code{QDialog} perchè sia modale, permette di visualizzare l'elenco degli ordini risultante da una ricerca. Inoltre, permette di rimuoverli o completarli tutti, chiedendo conferma all'utente attraverso un message box.
% subsubsection model_view_searchview (end)
% subsection altre_classi (end)
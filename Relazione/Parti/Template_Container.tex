\subsection{Template Container} % (fold)
\label{sub:template_container}
Le istanze del template di classe \code{Container<T>} sono contenitori che permettono di gestire collezioni di oggetti polimorfi (in caso non lo siano il template è comunque istanziabile, ma è necessario fornire specializzazioni ai template di funzione contenuti nel namespace \code{UniformInterface}, e il contenitore risultante è inutilmente appesantito). Siccome l'applicazione richiede che si possano eseguire inserimenti e rimozioni in posizione arbitraria nel container, si è scelto in fase di progettazione di utilizzare una lista doppiamente concatenata; si è inoltre scelto di fornire un'interfaccia pubblica il più simile possibile a quella del template \code{std::list<T>}.
\subsubsection{Classi annidate} % (fold)
\label{ssub:classi_annidate}
Essendo una lista concatenata, il template di classe si appoggia su un template di struttura annidata \code{Node}, che presenta diversi costruttori adatti ai diversi modi di passare gli oggetti da aggiungere al container come parametri, il distruttore, ed un overloading per l'operatore di uguaglianza, che esegue il confronto fra i campi info dei nodi considerati e dei successivi. Sono inoltre forniti due template di classe annidati \code{iterator<T>} e \code{const_iterator<T>}; in realtà, questi sono specializzazioni parziali del template di classe annidata \code{temp_iterator<T,constness>}, il cui parametro non-tipo \code{constness} è \code{true} per \code{const_iterator<T>} e \code{false} per \code{iterator<T>}. Questo, combinato con i template \code{reference<T,constness>} e \code{pointer<T,constness>} contenuti nel namespace \code{ReferenceTypes}, permette di evitare definire due classi separate, ma fortemente accoppiate, per gli iteratori e gli iteratori costanti, al costo di non permettere il cast da \code{iterator<T>} a \code{const_iterator<T>}. È fornito un costruttore privato ad un parametro, e per questo il template \code{Container} è dichiarato come template di classe friend associato, mentre il costruttore di default (che costruisce un iteratore non dereferenziabile) è pubblico; inoltre, sono presenti (e pubblici) i costruttori di copia e di move forniti dal compilatore, come anche i rispettivi operatori di assegnazione e il distruttore. Gli iteratori forniscono overloading per gli operatori di dereferenziazione, dereferenziazione e selezione, incremento e decremento prefisso e postfisso, e confronto. Il confronto è superficiale: l'operatore di uguaglianza ritorna \code{true} se e solo se i due iteratori puntano allo stesso nodo. In caso di comportamenti anomali, i metodi lanciano delle appropriate eccezioni.
% subsubsection classi_annidate (end)
\subsubsection{Metodi} % (fold)
\label{ssub:metodi}
\paragraph{Costruttori, Distuttore, Assegnazione} % (fold)
\label{par:costruttori_distuttore_assegnazione}
Il container fornisce 6 costruttori, di cui due sono il costruttore di copia e quello di move, i quali sono accompagnati dal distruttore e dagli operatori di assegnazione di copia e di move per la rule of five, che dallo standard C++11 ha sostituito la rule of three. I rimanenti costruttori permettono di costruire un container vuoto, un container di una data dimensione con nodi tutti uguali, un container a partire da un range, oppure un container a partire da una initializer list.
% paragraph costruttori_distuttore_assegnazione (end)
\paragraph{Iterazione} % (fold)
\label{par:iterazione}
Per l'iterazione sono forniti 6 metodi, completamente analoghi ai metodi \code{begin()}, \code{begin() const}, \code{cbegin() const}, \code{end()}, \code{end() const} e \code{cend() const} forniti dai container della STL. È inoltre fornito un metodo statico \code{toConstIter()} per convertire da \code{iterator<T>} a \code{const_iterator<T>}.
% paragraph iterazione (end)
\paragraph{Dimensione, Accesso, Inserimento, Rimozione} % (fold)
\label{par:dimensione_accesso_inserimento_rimozione}
Sono forniti un metodo \code{size()} che ritorna la dimensione della lista, e un metodo \code{empty()} che ritorna \code{true} se e solo se la lista è vuota, e metodi \code{front()} e \code{back()}, \code{const} e non, per l'accesso al primo e all'ultimo elemento. Sono forniti metodi \code{push_back()}, \code{push_front()}, \code{pop_back()}, e \code{pop_front()} per l'inserimento e la rimozione in testa e in coda alla lista (ciascuno dotato di diversi overloading),ed inoltre metodi \code{insert()} ed \code{erase()} per l'inserimento e la rimozione in posizione arbitraria, basati su iteratori. È fornito un metodo \code{clear()} per svuotare il container. Infine, sono forniti metodi \code{swap()} (in due versioni, per scambiare il contenuto di due container o di due nodi) e \code{give} (per spostare un nodo da un container ad un altro, o da un punto ad un altro nello stesso container);
% paragraph dimensione_accesso_inserimento_rimozione (end)
\paragraph{Ricerca, Confronto} % (fold)
\label{par:ricerca_confronto}
Sono forniti metodi \code{find()} e \code{find_if}, \code{const} e non, per la ricerca di elementi nel container (\code{find()} utilizza l'operatore di confronto fornito da \code{DeepPtr<T>}, mentre \code{find_if()} utilizza una funzione passata come parametro, la quale deve avere due parametri di tipo \code{const T &} e tipo di ritorno \code{bool}). Sono forniti inoltre operatori di confronto; l'operatore di uguaglianza ritorna \code{true} se e solo se i due container hanno gli stessi elementi nello stesso ordine.
% paragraph ricerca_confronto (end)
% subsubsection metodi (end)
% subsection template_container (end)